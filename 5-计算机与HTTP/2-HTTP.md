



# 概念及工作流程

## 基本概念

>重要性：可以简化说webservice = HTTP协议 + XML；Rest = HTTP协议 + JSON；各种API也是一般通过HTTP+XML/JSON来实现的

## HTTP请求信息和响应信息格式

> ### 1. 请求信息(请求报文)
>
> - 请求行（分为三部份）
>   - 请求方法（GET、POST、PUT、DELETE、TRACE、OPTIONS）--> POST比GET多了主体信息和Content-length
>   - 请求路径
>   - 所用协议（一般是HTTP/1.1）
> - 请求头信息
> - 请求主体信息（可以没有）
> - 头信息结束后和主体信息之间要空一行(即使没有主体信息也要空一行)
>
> ```http
> POST / 0606.02.PHP /1.1
> HOST:localhost  //Host：发出请求的页面所在的域
> Content-type:application/x-www-form-urlencode
> Content-length:5 
> 
> Age=3 //这是请求主体信息
> ```
>
> 请求方法：
>
> - HEAD：和GET基本一致，只是返回内容。比如我们只是确认一个内容(比如照片)还正常存在，不需要返回照片的内容,这时用HEAD比较合适
>
> - TRACE：是你用了代理上网,比如用代理访问new.163.com,你想看看代理有没有修改你的HTTP请求,可以用TRACE来测试一下, 163.com的服务器就会把最后收到的请求返回给你.
>
> - OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。OPTIONS方法是用于请求获得由`Request-URI`标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。该请求方法的响应不能缓存
>
>   OPTIONS请求方法的**主要用途**有两个：
>
>   - 获取服务器支持的所有HTTP请求方法；
>   - 用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。
>
> 
>
>
> ### 2.响应信息
>
> - 响应行
>   - 协议
>   - 状态码
>   - 状态文字
> - 响应头信息（格式为key:value）
> - 空行
> - 主体信息（也可能没有）
>
> ```http
> HTTP/1.1/200 OK
> Content-type:text/html
> Content-length:5
> 
> hello // 主体信息
> ```
> 状态码：
>
> - 200 - 服务器成功返回网页
> - 301/2 - 永久/临时重定向
> - 304 Not Modified - 未修改
> - 404 - 请求的网页不存在
> - 503 - 服务器暂时不可用
> - 500 - 服务器内部错误
>

# 补充：

## get和post区别

>GET 和 POST 方法是 HTTP 的两种请求方式，因为HTTP的规则和浏览器/服务器的限制，使得它们在应用过程中体现出不同
>
>- **作用不同**：GET 一般用于从服务端获取资源(例如请求网页资源)；POST 一般用来向服务端提交资源(例如注册用户操作)
>- **是否缓存：** 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存，除非手动设置
>- **参数传递方式不同**：GET 的参数一般是通过 `?` 跟在 URL 后面的，多个参数通过 `&` 连接，比如：`www.example.com?serach=bianchengsanmei&content=123`；POST 的参数一般是包含在 `request body` 中的（其实，这个区别不是绝对的，GET 也可以通过 params 携带参数，而 POST 的URL 后面也可以携带参数，只是通常不建议这么做）
>- **安全性不同**：因为参数传递方式的不同，GET 比 POST 更不安全，因为参数直接暴露在URL上，所以 GET 不能用来传递敏感信息（从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文，要想安全传输，就只有加密，也就是 HTTPS）
>- **参数数据类型不同**：参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制
>- **时间消耗不同**：GET 和 POST 请求时间的不同是因为GET 产生一个 TCP 数据包；而POST 产生两个 TCP 数据包。对于 GET 方式的请求，浏览器会把 `header` 和 `data` 一并发送出去，服务器响应 200（返回数据）；而对于 POST，浏览器先发送 `Header`，服务器响应 100 continue，浏览器再发送 `data`，服务器响应 200 ok（返回数据）
>- **参数长度限制不同**：POST传送的数据量较大，而GET传送的数据量较小（其实HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因）
>
>但是实际上HTTP 的底层是 TCP和IP；所以 GET 和 POST 的底层也是 TCP/IP，也就是说，**GET 和 POST 都是 TCP 链接**

## 常见的HTTP请求

>- GET: 向服务器获取数据；
>- POST：将实体提交到指定的资源，通常会造成服务器资源的修改（向服务端提交资源）
>- PUT：上传文件，更新数据（一般不会修改数据）
>- DELETE：删除服务器上的对象；
>- HEAD：获取报文首部，与GET相比，不返回报文主体部分
>- OPTIONS：询问支持的请求方法，用来跨域请求
>- CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信
>- TRACE: 回显服务器收到的请求，主要⽤于测试或诊断


## 常见的HTTP请求头和响应头

> **HTTP Request Header 常见的请求头：**
>
> - **Accept**:浏览器能够处理的内容类型
>   - Accept: text/html： 浏览器可以接受服务器回发的类型为 text/html。
>   - Accept: \*/*  代表浏览器可以处理所有类型(一般浏览器发给服务器都是发这个)
> - **Accept-Encoding**：浏览器声明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）- `Accept-Encoding: gzip, deflate`
> - **Accept-Language**：浏览器当前设置的语言 - `Accept-Language:zh-CN,zh;q=0.9`
> - **Connection**：浏览器与服务器之间连接的类型
>   - Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。
>   - Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。
> - **Host**（发送请求时，该报头域是必需的）：发出请求的页面所在的域（ 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的）- `Host:www.baidu.com`
> - **Referer**：发出请求的页面的URL(当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理)
> - **User-Agent**：告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本`User-Agent:Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36`
> - **Cookie**：当前页面设置的任何Cookie
>
> 
>
> **HTTP Responses Header 常见的响应头：**
>
> - **Date**：服务端发送资源时的服务器时间，GMT是格林尼治所在地的标准时间`Date: Tue, 03 Apr 2018 03:52:28 GMT`
> - **Server**:服务器名称和相对应的版本，只是告诉客户端服务器信息`Server：Tengine/1.4.6`
> - **Connection**：浏览器与服务器之间连接的类型，例如Connection:keep-alive就是回应客户端的Connection：keep-alive，告诉客户端服务器的tcp连接也是一个长连接，客户端可以继续使用这个tcp连接发送http请求
> - **Content-Type**：告诉客户端，资源文件的类型，还有字符编码，客户端通过utf-8对资源进行解码，然后对资源进行html解析`Content-Type：text/html;charset=UTF-8`
> - **Content-Encoding**：告诉客户端，服务端发送的资源是采用gzip编码的，客户端看到这个信息后，应该采用gzip对资源进行解码`Content-Encoding:gzip`
> - **Cache-Control**：控制HTTP缓存

## HTTP1.0和1.1的区别

> **连接方面**，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。
>
> **资源请求方面**，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
>
> **缓存方面**，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。
>
> http1.1 中**新增了 host 字段**，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。
>
> http1.1 相对于 http1.0 还新增了很多**请求方法**，如 PUT、HEAD、OPTIONS 等

## HTTP1.1和2.0的区别

> **二进制协议**：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。
>
> **多路复用：** HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了"队头堵塞"【1】的问题。
>
> **数据流：** HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。
>
> **头信息压缩：** HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。
>
> **服务器推送：** HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的
> 
## HTTP和HTTPS的区别
>- HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；
>- HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；
>- 使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；
>- HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全

## 对keep-alive的理解

> HTTP中有一个keep-alive；Vue中的路由也有一个keep-alive
>
> HTTP1.0 中默认是在每次请求/应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是**短连接**。当使用Keep-Alive模式时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接，这就是**长连接**。其使用方法如下：
>
> - HTTP1.0版本是默认没有Keep-alive的（也就是默认会发送keep-alive），所以要想连接得到保持，必须手动配置发送`Connection: keep-alive`字段。若想断开keep-alive连接，需发送`Connection:close`字段；
> - HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送`Connection：close`首部字段。
>
> Keep-Alive的**建立过程**：
>
> - 客户端向服务器在发送请求报文同时在首部添加发送Connection字段
> - 服务器收到请求并处理 Connection字段
> - 服务器回送Connection:Keep-Alive字段给客户端
> - 客户端接收到Connection字段
> - Keep-Alive连接建立成功
>
> **服务端自动断开过程（也就是没有keep-alive）**：
>
> - 客户端向服务器只是发送内容报文（不包含Connection字段）
> - 服务器收到请求并处理
> - 服务器返回客户端请求的资源并关闭连接
> - 客户端接收资源，发现没有Connection字段，断开连接
>
> **客户端请求断开连接过程**：
>
> - 客户端向服务器发送Connection:close字段
> - 服务器收到请求并处理connection字段
> - 服务器回送响应资源并断开连接
> - 客户端接收资源并断开连接
>
> 开启Keep-Alive的**优点：**
>
> - 较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；
> - 允许请求和应答的HTTP管线化；
> - 降低拥塞控制 （TCP连接减少了）；
> - 减少了后续请求的延迟（⽆需再进⾏握⼿）；
> - 报告错误⽆需关闭TCP连；
>
> 开启Keep-Alive的**缺点**：
>
> - 长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。

## HTTP协议的优缺点

>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。
>
>HTTP协议具有以下**优点**：
>
>- 支持客户端/服务器模式
>- **简单快速**：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。
>- **无连接**：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。
>- **灵活**：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。
>
>HTTP协议具有以下**缺点**：
>
>- **无状态：** HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。
>- **明文传输：** 协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。
>- **不安全**
>
>（1）通信使用明文（不加密），内容可能会被窃听； （2）不验证通信方的身份，因此有可能遭遇伪装； （3）无法证明报文的完整性，所以有可能已遭篡改；
>

## HTTP状态码总结
>状态码的类别：
>
>| **类别** | **原因**                        | **描述**                   |
>| -------- | ------------------------------- | -------------------------- |
>| 1xx      | Informational(信息性状态码)     | 接受的请求正在处理         |
>| 2xx      | Success(成功状态码)             | 请求正常处理完毕           |
>| 3xx      | Redirection(重定向状态码)       | 需要进行附加操作一完成请求 |
>| 4xx      | Client Error (客户端错误状态码) | 服务器无法处理请求         |
>| 5xx      | Server Error(服务器错误状态码)  | 服务器处理请求出错         |
>
>**（1）2XX 成功**
>
>- 200 OK，表示从客户端发来的请求在服务器端被正确处理
>- 204 No content，表示请求成功，但响应报文不含实体的主体部分
>- 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容
>- 206 Partial Content，进行范围请求
>
>**（2）3XX 重定向**
>
>- 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
>- 302 found，临时性重定向，表示资源临时被分配了新的 URL
>- 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源
>- 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
>- 307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求
>
>**（3）4XX 客户端错误**
>
>- 400 bad request，请求报文存在语法错误
>- 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
>- 403 forbidden，表示对请求资源的访问被服务器拒绝
>- 404 not found，表示在服务器上没有找到请求的资源
>
>**（4）5XX 服务器错误**
>
>- 500 internal sever error，表示服务器端在执行请求时发生了错误
>- 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能
>- 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求

## DNS的完整查询过程

> DNS服务器解析域名的过程：
>
> - 首先会在**浏览器的缓存**中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步
> - 将请求发送给**本地DNS服务器**，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步
> - 本地DNS服务器向**根域名服务器**发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址
> - 本地DNS服务器向**顶级域名服务器**发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址
> - 本地DNS服务器向**权威域名服务器**发送请求，域名服务器返回对应的结果
> - 本地DNS服务器将返回结果保存在缓存中，便于下次使用
> - 本地DNS服务器将返回结果返回给浏览器
>
> 比如要查询 [www.baidu.com](https://link.juejin.cn?target=http%3A%2F%2Fwww.baidu.com%2F) 的 IP 地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。
