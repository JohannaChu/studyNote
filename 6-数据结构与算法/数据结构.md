# 数据结构

## 逻辑结构

> 指数据对象中数据元素之间的相互关系（面向问题），包括以下几类：
>
> - 集合结构:集合结构中的数据元素除了同属于一个集合外,它们之间没有其他关系
> - 线性结构:线性结构中的数据元素之间是一对一的关系
> - 树形结构:树形结构中的数据元素之间存在一种一对多的层次关系
> - 图形结构:图形结构的数据元素是多对多的关系

## 物理结构

> 指数据的逻辑结构在计算机中的存储形式(面向计算机)，有两类
>
> - 顺序存储结构:是把数据元素存放在地址连续的存储单元里,其数据间的逻辑关系和物理关系是一致的
> - 链式存储结构:是把数据元素存放在任意的存储单元里,这组存储单元可以是连续的,也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系,因此需要用一个指针存放数据元素的地址,这样通过地址就可以找到相关联数据元素的位置

# 线性表

> 是零个或多个数据元素的有限序列
>
## 顺序存储结构
>指的是用一段地址连续的存储单元依次存储线性表的数据元素（常用数组实现此结构）--> 数组的长度是存放线性表的存储空间的长度,存储分配后这个量是一般是不变的。线性表的长度是线性表中数据元素的个数,随看线性表插入和删除操作的进行,这个量是变化的。
>
>- 存、读数据时不管哪个位置时间复杂度都是O(1)
>- 插入和删除的时间复杂度都是O(n)
>
>因此比较适合元素个数不大变化，更多是存取数据的应用；·顺序存储结构需要预分配存储空间,分大了,浪费,分小了易发生上溢
>
## 链式存储结构
>用一组任意的存储单元存储线性表的数据元素,这组存储单元可以是连续的,也可以是不连续的。这就意味着,这些数据元素可以存在内存未被占用的任意位置。（除了要存数据元素信息外，还需要存储后继元素的存储地址，因此包含数据域和指针域，两者组成一个结点）
>
>- 查找的复杂度为O(n)
>- 插入和删除的时间复杂度都是O(1)（找到插入或删除位置的复杂度为O(n)，但找到后的插入和删除一个或多个的时间复杂度为O(1)）
>
>对插入或删除数据越频繁的操作，单链表的效率优势越明显；单链表不需要分配存储空间,只要有就可以分配,元素个数也不受限制

## 静态链表

>让数组的元素都是由两个数据域组成, data和cur。数据域data,用来存放数据元素,也就是通常我们要处理的数据;而游标cur相当于单链表中的next指针,存放该元素的后继在数组中的下标。另外我们对数组第一个和最后一个元素作为特殊元素处理,不存数据。
>
>- 优点：在插入和删除操作时,只需要修改游标,不需要移动元素,从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点
>- 缺点：没有解决连续存储分配带来的表长难以确定的问题；失去了顺序存储结构随机存取的特性

## 其他链表

>链式存储结构的不同形式：单链表、循环链表、双向链表
>
>- 循环链表：将单链表中终端结点的指针端由空指针改为指向头结点,就使整个单链表形成一个环,这种头尾相接的单链表称为单循环链表,简称循环链表
>- 双向链表：在单链表的每个结点中,再设置一个指向其前驱结点的指针域。所以在双向链表中的结点都有两个指针域,一个指向直接后继,另一个指向直接前驱。

# 栈与队列(特殊的线性表)

>栈和队列都是特殊的线性表,只不过对插入和删除操作做了限制。栈(stack)是限定仅在表尾进行插入和删除操作的线性表。队列(queue)是只允许在一端进行插入操作,而在另一端进行删除操作的线性表。

## 栈

>栈(stack )是限定仅在表尾进行插入和删除操作的**线性表**。含任何数据元素的栈称为空栈。栈又称为**后进先出**(Last In First Out)的线性表,简称LIFO结构（**先进后出**）。
>
>- 顺序存储结构：进栈出栈相当于增加删除，复杂度为O(1)
>- 链式存储结构：进栈出栈复杂度为O(1)
>
>如果栈的使用过程中元素变化不可预料,有时很小,有时非常大,那么最好是用链栈,反之,如果它的变化在可控范围内,建议使用顺序栈会更好一些。
>
>栈的应用之一就是递归

## 队列

>队列(queue)是只允许在一端进行插入操作,而在另一端进行删除操作的线性表。队列是一种先进先出(First In First Out)的线性表,简称FIFO。允许插入的一端称为队尾,允许删除的一端称为队头。
>
>队列插入数据只能在队尾进行，删除数据只能在队头进行（相当于先进先出，出去则意味着删除，进来则意味着插入）
>
>- 顺序存储的插入复杂度为O(1)，但是删除复杂度为O(n)（因为删除队列的所有元素都要向前移动一位）
>- 链式存储（链队列）出栈和入栈的复杂度都是O(1)
>
>在可以确定队列长度最大值的情况下,建议用循环队列,如果无法预估队列的长度时,则用链队列。

# 串

>串( string )是由零个或多个字符组成的有限序列,又名叫字符串。（本质上是一种线性表的扩展，但相对于线性表关注一个个元素来说，串更多的是关注它子串的应用问题，如查找、替换等操作）
>
>- 串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。按照预定义的大小,为每个定义的串变量分配一个固定长度的存储区。一般是用定长数组来定义。
>- 串的链式存储结构除了在连接串与串操作时有一定方便之外,总的来说不如顺序存储灵活,性能也不如顺序存储结构好。
>
>串的最重要的应用之一就是模式匹配（类似去找一个单词在一篇文章(相当于一个大字符串)中的定位问题）
>解决这个问题的其中之一个算法就是KMP模式匹配算法

# 树

>树(Tree)是n (n>0)个结点的有限集。n=0时称为空树。在任意一棵非空树中:(1)有且仅有一个特定的称为根(Root)的结点; (2)当n>1时,其余结点可分为m(m>0)个互不相交的有限集T1、T2、……、Tm,其中每一个集合本身又是一棵树,并且称为根的子树( SubTree )。

## 存储结构

>- 双亲表示法：假设以一组连续空间存储树的结点,同时在每个结点中,附设一个指示器指示其双亲结点到链表中的位置。也就是说,每个结点除了知道自己是谁以外,还知道它的双亲在哪里。其中data是数据域,存储结点的数据信息。而parent是指针域,存储该结点的双亲在数组中的下标。
>- 孩子表示法：把每个结点的孩子结点排列起来,以单链表作存储结构,则n个结点有n个孩子链表,如果是叶子结点则此单链表为空，然后n个头指针又组成一个线性表,采用顺序存储结构,存放进一个一维数组中
>- 孩子兄弟表示法：任意一棵树,它的结点的第一个孩子如果存在就是唯一的,它的右兄弟如果存在也是唯一的。因此,我们设置两个指针,分别指向该结点的第一个孩子和此结点的右兄弟。

## 二叉树

>二叉树(Binary Tree )是n(n>0)个结点的有限集合,该集合或者为空集(称为空二叉树),或者由一个根结点和**两棵**互不相交的、分别称为根结点的左子树和右子树的二叉树组成。(每个结点最多有两棵子树,所以二叉树中不存在度大于2的结点。注意不是只有两棵子树,而是最多有。没有子树或者有一棵子树都是可以的。)
>
### 性质
>
>- 性质1:在二叉树的第i层上至多有2^(i-1)个结点(i>1)
>- 性质2:深度为k的二叉树至多有(2^k)-1个结点(k>1)
>- 性质3:对任何一棵二叉树T,如果其终端结点数为n0,度为2的结点数为n2,则n0=n2+1(终端结点数其实就是叶子结点数,而一棵二叉树,除了叶子结点外,剩下的就是度为1或2的结点数了)
>- 性质4:具有n个结点的完全二叉树的深度为[log2n]+1 ([x]表示不大于x的最大整数)
>- 性质5:如果对一棵有n个结点的完全二叉树(其深度为[log2n]+1)的结点按层序编号(从第1层到第[log2n]+1层,每层从左到右),对任一结点i (1<=i<=n)有：
>
>  - 如果 i=1, 则结点i是二叉树的根，无双亲；如果 i>1,则其双亲是结点[i/2]
>  - 如果2i>n,则结点i无左孩子(结点i为叶子结点);否则其左孩子是结点2i
>  - 如果2i+1>n,则结点i无右孩子;否则其右孩子是结点2i+1

### 遍历方法

> - 前序遍历：规则是若二叉树为空,则空操作返回,否则先访问根结点,然后前序遍历左子树,再前序遍历右子树
> - 中序遍历：规则是若树为空,则空操作返回,否则从根结点开始(注意并不是先访问根结点),中序遍历根结点的左子树,然后是访问根结点,最后中序遍历右子树
> - 后序遍历：规则是若树为空,则空操作返回,否则从左到右先叶子后结点的方式遍历访问左右子树,最后是访问根结点
> - 层序遍历：规则是若树为空,则空操作返回,否则从树的第一层,也就是根结点开始访问,从上而下逐层遍历,在同一层中,按从左到右的顺序对结点逐个访问

# 图

>图(Graph )是由顶点的有穷非空集合和顶点之间边的集合组成,通常表示为:G(V,E),其中,G表示一个图,V是图G中顶点的集合,E是图G中边的集合。
>
>- 线性表中把数据元素叫元素,树中将数据元素叫结点,在图中数据元素,则称之为顶点(Vertex)。
>
>- 线性表中可以没有数据元素,称为空表。树中可以没有结点,叫做空树。在图结构中,不允许没有顶点。在定义中,若V是顶点的集合,则强调了顶点集合V有穷非空。
>
>- 线性表中,相邻的数据元素之间具有线性关系,树结构中,相邻两层的结点具有层次关系,而图中,任意两个顶点之间都可能有关系,顶点之间的逻辑关系用边来表示,边集可以是空的。
>
## 定义和术语
>
>- 图按照有无方向分为无向图和有向图。无向图由顶点和边构成,有向图由顶点和弧构成。弧有弧尾和弧头之分。
>- 图按照边或弧的多少分稀疏图和稠密图。如果任意两个顶点之间都存在边叫完全图,有向的叫有向完全图。若无重复的边或顶点到自身的边则叫简单图。
>- 图中顶点之间有邻接点、依附的概念。无向图顶点的边数叫做度,有向图顶点分为入度和出度。图上的边或弧上带权则称为网。
>- 图中顶点间存在路径,两顶点存在路径则说明是连通的,如果路径最终回到起始点则称为环,当中不重复叫简单路径。若任意两顶点都是连通的,则图就是连通图,有向则称强连通图。图中有子图,若子图极大连通则就是连通分量,有向的则称强连通分量。
>- 无向图中连通且n个顶点n-1条边叫生成树。有向图中一顶点入度为0其余顶度为1的叫有向树。一个有向图由若干棵有向树构成生成森林

## 存储结构

>- 邻接矩阵：存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息,一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。
>- 邻接表：
>
>
