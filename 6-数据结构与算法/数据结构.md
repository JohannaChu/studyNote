# 数据结构

## 逻辑结构

> 指数据对象中数据元素之间的相互关系（面向问题），包括以下几类：
>
> - 集合结构:集合结构中的数据元素除了同属于一个集合外,它们之间没有其他关系
> - 线性结构:线性结构中的数据元素之间是一对一的关系
> - 树形结构:树形结构中的数据元素之间存在一种一对多的层次关系
> - 图形结构:图形结构的数据元素是多对多的关系

## 物理结构

> 指数据的逻辑结构在计算机中的存储形式(面向计算机)，有两类
>
> - 顺序存储结构:是把数据元素存放在地址连续的存储单元里,其数据间的逻辑关系和物理关系是一致的
> - 链式存储结构:是把数据元素存放在任意的存储单元里,这组存储单元可以是连续的,也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系,因此需要用一个指针存放数据元素的地址,这样通过地址就可以找到相关联数据元素的位置

# 线性表

> 是零个或多个数据元素的有限序列
>
## 顺序存储结构
>指的是用一段地址连续的存储单元依次存储线性表的数据元素（常用数组实现此结构）--> 数组的长度是存放线性表的存储空间的长度,存储分配后这个量是一般是不变的。线性表的长度是线性表中数据元素的个数,随看线性表插入和删除操作的进行,这个量是变化的。
>
>- 存、读数据时不管哪个位置时间复杂度都是O(1)
>- 插入和删除的时间复杂度都是O(n)
>
>因此比较适合元素个数不大变化，更多是存取数据的应用；·顺序存储结构需要预分配存储空间,分大了,浪费,分小了易发生上溢
>
## 链式存储结构
>用一组任意的存储单元存储线性表的数据元素,这组存储单元可以是连续的,也可以是不连续的。这就意味着,这些数据元素可以存在内存未被占用的任意位置。（除了要存数据元素信息外，还需要存储后继元素的存储地址，因此包含数据域和指针域，两者组成一个结点）
>
>- 查找的复杂度为O(n)
>- 插入和删除的时间复杂度都是O(1)（找到插入或删除位置的复杂度为O(n)，但找到后的插入和删除一个或多个的时间复杂度为O(1)）
>
>对插入或删除数据越频繁的操作，单链表的效率优势越明显；单链表不需要分配存储空间,只要有就可以分配,元素个数也不受限制

## 静态链表

>让数组的元素都是由两个数据域组成, data和cur。数据域data,用来存放数据元素,也就是通常我们要处理的数据;而游标cur相当于单链表中的next指针,存放该元素的后继在数组中的下标。另外我们对数组第一个和最后一个元素作为特殊元素处理,不存数据。
>
>- 优点：在插入和删除操作时,只需要修改游标,不需要移动元素,从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点
>- 缺点：没有解决连续存储分配带来的表长难以确定的问题；失去了顺序存储结构随机存取的特性

## 其他链表

>链式存储结构的不同形式：单链表、循环链表、双向链表
>
>- 循环链表：将单链表中终端结点的指针端由空指针改为指向头结点,就使整个单链表形成一个环,这种头尾相接的单链表称为单循环链表,简称循环链表
>- 双向链表：在单链表的每个结点中,再设置一个指向其前驱结点的指针域。所以在双向链表中的结点都有两个指针域,一个指向直接后继,另一个指向直接前驱。

# 栈与队列(特殊的线性表)

>栈和队列都是特殊的线性表,只不过对插入和删除操作做了限制。栈(stack)是限定仅在表尾进行插入和删除操作的线性表。队列(queue)是只允许在一端进行插入操作,而在另一端进行删除操作的线性表。

## 栈

>栈(stack )是限定仅在表尾进行插入和删除操作的**线性表**。含任何数据元素的栈称为空栈。栈又称为**后进先出**(Last In First Out)的线性表,简称LIFO结构（**先进后出**）。
>
>- 顺序存储结构：进栈出栈相当于增加删除，复杂度为O(1)
>- 链式存储结构：进栈出栈复杂度为O(1)
>
>如果栈的使用过程中元素变化不可预料,有时很小,有时非常大,那么最好是用链栈,反之,如果它的变化在可控范围内,建议使用顺序栈会更好一些。
>
>栈的应用之一就是递归

## 队列

>队列(queue)是只允许在一端进行插入操作,而在另一端进行删除操作的线性表。队列是一种先进先出(First In First Out)的线性表,简称FIFO。允许插入的一端称为队尾,允许删除的一端称为队头。
>
>队列插入数据只能在队尾进行，删除数据只能在队头进行（相当于先进先出，出去则意味着删除，进来则意味着插入）
>
>- 顺序存储的插入复杂度为O(1)，但是删除复杂度为O(n)（因为删除队列的所有元素都要向前移动一位）
>- 链式存储（链队列）出栈和入栈的复杂度都是O(1)
>
>在可以确定队列长度最大值的情况下,建议用循环队列,如果无法预估队列的长度时,则用链队列。

# 串

>串( string )是由零个或多个字符组成的有限序列,又名叫字符串。（本质上是一种线性表的扩展，但相对于线性表关注一个个元素来说，串更多的是关注它子串的应用问题，如查找、替换等操作）
>
>- 串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。按照预定义的大小,为每个定义的串变量分配一个固定长度的存储区。一般是用定长数组来定义。
>- 串的链式存储结构除了在连接串与串操作时有一定方便之外,总的来说不如顺序存储灵活,性能也不如顺序存储结构好。
>
>串的最重要的应用之一就是模式匹配（类似去找一个单词在一篇文章(相当于一个大字符串)中的定位问题）
>解决这个问题的其中之一个算法就是KMP模式匹配算法

# 树

>树(Tree)是n (n>0)个结点的有限集。n=0时称为空树。在任意一棵非空树中:(1)有且仅有一个特定的称为根(Root)的结点; (2)当n>1时,其余结点可分为m(m>0)个互不相交的有限集T1、T2、……、Tm,其中每一个集合本身又是一棵树,并且称为根的子树( SubTree )。

## 存储结构

>- 双亲表示法：假设以一组连续空间存储树的结点,同时在每个结点中,附设一个指示器指示其双亲结点到链表中的位置。也就是说,每个结点除了知道自己是谁以外,还知道它的双亲在哪里。其中data是数据域,存储结点的数据信息。而parent是指针域,存储该结点的双亲在数组中的下标。
>- 孩子表示法：把每个结点的孩子结点排列起来,以单链表作存储结构,则n个结点有n个孩子链表,如果是叶子结点则此单链表为空，然后n个头指针又组成一个线性表,采用顺序存储结构,存放进一个一维数组中
>- 孩子兄弟表示法：任意一棵树,它的结点的第一个孩子如果存在就是唯一的,它的右兄弟如果存在也是唯一的。因此,我们设置两个指针,分别指向该结点的第一个孩子和此结点的右兄弟。

## 二叉树

>二叉树(Binary Tree )是n(n>0)个结点的有限集合,该集合或者为空集(称为空二叉树),或者由一个根结点和**两棵**互不相交的、分别称为根结点的左子树和右子树的二叉树组成。(每个结点最多有两棵子树,所以二叉树中不存在度大于2的结点。注意不是只有两棵子树,而是最多有。没有子树或者有一棵子树都是可以的。)
>
### 性质
>
>- 性质1:在二叉树的第i层上至多有2^(i-1)个结点(i>1)
>- 性质2:深度为k的二叉树至多有(2^k)-1个结点(k>1)
>- 性质3:对任何一棵二叉树T,如果其终端结点数为n0,度为2的结点数为n2,则n0=n2+1(终端结点数其实就是叶子结点数,而一棵二叉树,除了叶子结点外,剩下的就是度为1或2的结点数了)
>- 性质4:具有n个结点的完全二叉树的深度为[log2n]+1 ([x]表示不大于x的最大整数)
>- 性质5:如果对一棵有n个结点的完全二叉树(其深度为[log2n]+1)的结点按层序编号(从第1层到第[log2n]+1层,每层从左到右),对任一结点i (1<=i<=n)有：
>
>  - 如果 i=1, 则结点i是二叉树的根，无双亲；如果 i>1,则其双亲是结点[i/2]
>  - 如果2i>n,则结点i无左孩子(结点i为叶子结点);否则其左孩子是结点2i
>  - 如果2i+1>n,则结点i无右孩子;否则其右孩子是结点2i+1

### 遍历方法

> - 前序遍历：规则是若二叉树为空,则空操作返回,否则先访问根结点,然后前序遍历左子树,再前序遍历右子树
> - 中序遍历：规则是若树为空,则空操作返回,否则从根结点开始(注意并不是先访问根结点),中序遍历根结点的左子树,然后是访问根结点,最后中序遍历右子树
> - 后序遍历：规则是若树为空,则空操作返回,否则从左到右先叶子后结点的方式遍历访问左右子树,最后是访问根结点
> - 层序遍历：规则是若树为空,则空操作返回,否则从树的第一层,也就是根结点开始访问,从上而下逐层遍历,在同一层中,按从左到右的顺序对结点逐个访问

# 图

>图(Graph )是由顶点的有穷非空集合和顶点之间边的集合组成,通常表示为:G(V,E),其中,G表示一个图,V是图G中顶点的集合,E是图G中边的集合。
>
>- 线性表中把数据元素叫元素,树中将数据元素叫结点,在图中数据元素,则称之为顶点(Vertex)。
>
>- 线性表中可以没有数据元素,称为空表。树中可以没有结点,叫做空树。在图结构中,不允许没有顶点。在定义中,若V是顶点的集合,则强调了顶点集合V有穷非空。
>
>- 线性表中,相邻的数据元素之间具有线性关系,树结构中,相邻两层的结点具有层次关系,而图中,任意两个顶点之间都可能有关系,顶点之间的逻辑关系用边来表示,边集可以是空的。
>
## 定义和术语
>
>- 图按照有无方向分为无向图和有向图。无向图由顶点和边构成,有向图由顶点和弧构成。弧有弧尾和弧头之分。
>- 图按照边或弧的多少分稀疏图和稠密图。如果任意两个顶点之间都存在边叫完全图,有向的叫有向完全图。若无重复的边或顶点到自身的边则叫简单图。
>- 图中顶点之间有邻接点、依附的概念。无向图顶点的边数叫做度,有向图顶点分为入度和出度。图上的边或弧上带权则称为网。
>- 图中顶点间存在路径,两顶点存在路径则说明是连通的,如果路径最终回到起始点则称为环,当中不重复叫简单路径。若任意两顶点都是连通的,则图就是连通图,有向则称强连通图。图中有子图,若子图极大连通则就是连通分量,有向的则称强连通分量。
>- 无向图中连通且n个顶点n-1条边叫生成树。有向图中一顶点入度为0其余顶度为1的叫有向树。一个有向图由若干棵有向树构成生成森林

## 存储结构

>- 邻接矩阵：存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息,一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。
>- 邻接表：把数组和链表相结合的存储方法
>- 十字链表：邻接表和逆邻接表整合在了一起,这样既容易找到以vi为尾的弧,也容易找到以vi为头的弧,因而容易求得顶点的出度和入度。而且它除了结构复杂一点外,其实创建图算法的时间复杂度是和邻接表相同的

## 遍历方法

>从图中某一顶点出发访遍图中其余顶点,且使每一个顶点仅被访问一次
>
>- 深度优先遍历：它从图中某个顶点v出发,访问此顶点,然后从v的未被访问的邻接点出发深度优先遍历图,直至图中所有和v有路径相通的顶点都被访问到
>- 广度优先遍历：类似分层搜索

# 查找

>查找表(Search Table)是由同一类型的数据元素(或记录)构成的集合
>关键字(Key)是数据元素中某个数据项的值,又称为键值；用它可以标识一个数据元素，也可以标识一个记录的某个数据项(字段)，又称为关键码
>
>查找(Searching)就是根据给定的某个值,在查找表中确定一个其关键字等于给定值的数据元素(或记录)
>
>查找表查找方法：
>
>- 静态查找表：只作查找操作的查找表。它的主要操作有:
>  - (1)查询某个“特定的”数据元素是否在查找表中
>  - (2)检索某个“特定的”数据元素和各种属性
>- 动态查找表：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。显然动态查找表的操作就是两个
>  - (1)查找时插入数据元素
>  - (2)查找时删除数据元素

## 查找技术

### 顺序表查找

>- 顺序查找，又叫线性查找,是最基本的查找技术。它的查找过程是:从表中第一个(或最后一个)记录开始,逐个进行记录的关键字和给定值比较,若某个记录的关键字和给定值相等,则查找成功,找到所查的记录;如果直到最后一个(或第一个)记录,其关键字和给定值比较都不等时,则表中没有所查的记录,查找不成功。(复杂度为O(n))
>
### 有序表查找
>
>- 折半查找技术,又称为二分查找。它的前提是线性表中的记录必须是关键码有序(通常从小到大有序),线性表必须采用顺序存储。折半查找的基本思想是:在有序表中,取中间记录作为比较对象,若给定值与中间记录的关键字相等,则查找成功;若给定值小于中间记录的关键字,则在中间记录的左半区继续查找;若给定值大于中间记录的关键字,则在中间记录的右半区继续查找。不断重复上述过程,直到查找成功,或所有查找区域无记录,查找失败为止。（复杂度为O(logn)）
>
>- 插值查找法：是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法,其核心就在于插值的计算公式（key-a[low]）/（a[high] - a[low]）。复杂度为O(logn)
>- 斐波那契查找：复杂度为O(logn)
>
>**线性索引查找**
>
>- 稠密索引：是指在线性索引中,将数据集中的每个记录对应一个索引项。对于稠密索引这个索引表来说,索引项一定是按照关键码有序的排列
>- 分块索引
>- 倒排索引：像在实际应用中需要根据属性(或字段、次关键码)的值来查找记录（由属性值来确定记录的位置）

## 二叉排序树

>又称为二叉查找树。它或者是一棵空树,或者是具有下列性质的二叉树，是动态查找最重要的数据结构
>
>- 若它的左子树不空,则左子树上所有结点的值均小于它的根结构的值
>- 若它的右子树不空,则右子树上所有结点的值均大于它的根结点的值
>- 它的左、右子树也分别为二叉排序树

## 散列表查找

>散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f,使得每个关键字key对应一个存储位置f(key)。查找时,根据这个确定的对应关系找到给定值key的映射f(key),若查找集合中存在这个记录,则必定在f(key)的位置上。其中的f称为散列函数，又称哈希函数
>
>**散列函数构造方法**
>
>- 直接定址法：取关键字的某个线性函数值为散列地址，即f( key ) =a * key+b (a, b为常数) （这样的散列函数优点就是简单、均匀,也不会产生冲突,但问题是这需要事先知道关键字的分布情况,适合查找表较小且连续的情况）
>- 平方取中法：适合于不知道关键字的分布，而位数又不是很大的情况
>- 折叠法：将关键字从左到右分割成位数相等的几部分(注意最后一部分位数不够时可以短些),然后将这几部分叠加求和,并按散列表表长,取后几位作为散列地址。（事先不需要知道关键字的分布,适合关键字位数较多的情况）
>- 除留余数法：f( key ) = key mod p (p<=m) mod表示取余（若散列表表长为m,通常p为小于或等于表长(最好接近m)的最小质数或不包含小于20质因子的合数）
>
>**处理散列冲突的方法**
>
>- 开放定址法：fi(key) = ((f(key) + di) MOD m) (di是一个随机数列)
>- 再散列函数法：事先准备多个散列函数 fi(key) =RHi(key) (i=1,2,...,k)

# 排序

>假设含有n个记录的序列为{r1,r2,...,rn},其相应的关键字分别为{k1,k2,…kn},需确定1, 2,., n的一种排列p1,p2,...,pn,使其相应的关键字满足kp1<Kp2<...<kpn (非递减或非递增)关系,即使得序列成为一个按关键字有序的序列{Γp1,Γp2,...,「pn),这样的操作就称为排序。
>
>- 内排序：是在排序整个过程中,待排序的所有记录全部被放置在内存中
>- 外排序：由于排序的记录个数太多,不能同时放置在内存,整个排序过程需要在内外存之间多次交换数据才能进行

## 排序算法

>- 冒泡排序：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止
>- 简单选择排序法：通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i（1<=i<=n）个记录交换
>- 直接插入排序：是将一个记录插入到已经排好序的有序表中,从而得到一个新的、记录数增1的有序表

